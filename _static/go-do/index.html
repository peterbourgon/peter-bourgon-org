<!DOCTYPE html>
<html>
<head>
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<title>Go Do</title>
<link href="http://fonts.googleapis.com/css?family=Lato:400,900|Averia+Libre:300" rel="stylesheet" type="text/css" />
<link href="presentation.css" rel="stylesheet" type="text/css" />
<script type="text/javascript" src="http://ajax.googleapis.com/ajax/libs/jquery/1.7/jquery.min.js"></script>
</head>

<body class="impress-not-supported">

<div id="c">
<div id="impress">

<!-- - - - - - -->

<div class="step slide title" data-x="-1500" data-y="-1000">
<h1>Go Do</h1>
<h2>Peter Bourgon</h2>
</div>

<!-- - - - - - -->

<div class="step slide" data-x="0" data-y="-1000">
<h1>peter.bourgon.org/go-do</h1>
<p>
	<br/>
	If you have trouble seeing the slides, or want to play with the
	interactive code (later on), you can access this presentation here.
</p>
</div>

<!-- - - - - - -->

<div class="step slide title" data-x="1500" data-y="-1000">
<h1>Software engineering</h1>

<p>
	is concerned with <strong>developing</strong> and
	<strong>maintaining</strong> software systems that behave reliably and
	efficiently, are affordable to develop and maintain, and satisfy all the
	requirements that customers have defined for them.
</p>

<p style="font-style:italic; margin-left:34px;">
&mdash;<a href="http://computingcareers.acm.org/?page_id=12">ACM</a>
</p>

</div>

<!-- - - - - - -->

<div class="step slide visual" data-x="3000" data-y="-1000">
<img src="img/placeholder.jpg" />

<p>
	I think of developing and maintaining as processes.
	In both cases, I'm looking at the system as it exists now,
	and comparing that against how the system should exist in the ideal case.
	And the better I am at what I do, the better I can perform that transformation.
</p>
</div>

<!-- - - - - - -->

<div class="step slide" data-x="4500" data-y="-1000">
<h1>Why Go?</h1>

<p>
	To help us walk the line between "now" and "later", we use tools.
	<br/><br/>
	<strong>I think Go is a really excellent tool.</strong>
	<br/><br/>
	It provides a small set of primitives that are orthogonal to each other,
	and can be easily combined to build solutions to a large class of problems.

	Those solutions tend to be decomposable, testable, and maintainable.
</p>
</div>

<!-- - - - - - -->
<!-- TODO somehow better transition between ^^^ and vvv -->
<!-- - - - - - -->

<div class="step slide visual" data-x="6000" data-y="-1000">

<img src="img/placeholder.jpg" />

<p>
	Because the primitives are so powerful, solving a problem
	<em>correctly</em>&mdash;ie. <em>ideally</em>&mdash;is possible
	without leaning heavily on libraries or frameworks.
</p>

</div>

<!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->

<div class="step slide title" data-x="0" data-y="0">
<h1>Go in 3 minutes</h1>
</div>

<!-- - - - - - -->

<div class="step slide code" data-x="1500" data-y="0">
<h1>Syntax</h1>

<div><pre>
package main

import "fmt"

func main() {
	var s1 string = "Jónsi"
	s2 := "Jón Þór Birgisson"

	fmt.Printf("%s, or '%s' for short\n", s1, s2)
}
</pre></div>

<p>
	<em style="background-color:yellow;">
		Note that every slide with code on it will be interactive,
		editable, compilable, and runnable in situ. See
		<a href="http://tour.golang.org">the Go Tour</a>
		for an example.
	</em>
	<br/><br/>
	Every Go source file is a member of a package.
	"main" implies an executable; everything else implies a library.
	<br/><br/>
	Import statements are straightforward.
	<br/><br/>
	'func' keyword defines a function.
	Variables may be explicitly typed (s1) or implicitly typed (s2).
	Note that this is not duck typing: s2 is syntax sugar for s1.
	<br/><br/>
	Printf is a function defined in the 'fmt' package, and is called this way.
</p>
</div>

<!-- - - - - - -->

<div class="step slide code" data-x="3000" data-y="0">
<h1>Types</h1>

<div><pre>
type Thing struct {
	Name  string
	Value int
}

type Celsius float32
type Fahrenheit float32

func main() {
	c := Celsius(0)
	f := Fahrenheit(32)

	// compiler error
	if c == f {
		fmt.Println("It's cold!")
	}
}
</pre></div>

<p>
	Types are concrete things which may be defined by the user via
	the <strong>type</strong> keyword. Commonly structs, but also aliases.
	Note that <strong>type</strong> always defines a new (ie. distinct) type,
	which is not interchangable with the thing it's based on.
</p>
</div>

<!-- - - - - - -->

<div class="step slide code" data-x="4500" data-y="0">
<h1>Interfaces</h1>

<div><pre>
type Reader interface {
	Read(n int) ([]byte, error)
}

// TODO expand example
</pre></div>

<p>
	Interfaces specify behavior:
	"if something can do <em>this</em>, then it can be used <em>here</em>".
	<br/><br/>
	Similar to an abstract class in Java.
	They operate in the behavior domain, rather than the implementation domain.
	<br/><br/>
	Concrete types which implement all of an interface's methods
	<em>implement</em> that interface.
	<br/><br/>
	Interfaces are first-class citizens in Go.
	Most standard-library functions take interfaces as parameters.
</p>
</div>

<!-- - - - - - -->

<div class="step slide code" data-x="6000" data-y="0">
<h1>Goroutines</h1>

<div><pre>
doSomething()
go doSomething()

// TODO expand example
</pre></div>

<p>
	Goroutines are essentially coroutines,
	from Tony Hoare's
	<a href="http://en.wikipedia.org/wiki/Communicating_sequential_processes">
		Communicating Sequential Processes
	</a>.
	Like very lightweight threads; multiplexed onto operating system threads.
	<br/><br/>
	Launch any function call in a new goroutine with the <strong>go</strong> keyword.
	You don't get handles, or any explicit management of goroutines.
</p>
</div>

<!-- - - - - - -->

<div class="step slide code" data-x="7500" data-y="0">
<h1>Channels</h1>

<div><pre>
produce := func(c chan int) {
	c <- 1 // put data onto channel
	c <- 2
	c <- 5
	c <- 3
	close(c)
}

consume := func(c chan int) {
	for {
		i, ok := <-c // read data from channel
		if !ok {
			break
		}
		fmt.Println(i)
	}
}

c := make(chan int)
go produce(c)
consume(c) // what about 'go consume(c)'?
</pre></div>

<p>
	Communication between goroutines is idiomatically accomplished
	with channels, which are typed, synchronized, and optionally-
	buffered pipes for data.
	<br/><br/>
	"Don't communicate by sharing memory; share memory by communicating."
</p>
</div>

<!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->

<div class="step slide title" data-x="0" data-y="1000">
<h1>Example 1</h1>
<h2>Aggregating data from multiple backends</h2>
</div>

<!-- - - - - - -->

<div class="step slide code" data-x="1500" data-y="1000">
<h1>Query v1</h1>
<div><pre>
package main

import (
	"fmt"
	"math/rand"
	"time"
)

type Backend interface {
	Query(q string) string
}

type FooBackend string
func (b FooBackend) Query(q string) string {
	time.Sleep(time.Duration(rand.Intn(100)) * time.Millisecond)
	// TODO why can 'b' satisfy '%s'?
	return fmt.Sprintf("Foo:%s:%s", b, q)
}

type BarBackend int
func (b BarBackend) Query(q string) string {
	time.Sleep(time.Duration(rand.Intn(100)) * time.Millisecond)
	// TODO why can 'b' satisfy '%d'?
	return fmt.Sprintf("Bar:%d:%s", b, q)
}

func QueryAll(q string, backends ...Backend) []string {
	results := []string{}
	for _, backend := range backends {
		r := backend.Query(q)
		results = append(results, r)
	}
	return results
}

func main() {
	rand.Seed(time.Now().UnixNano())
	var b1 FooBackend = "abc"
	var b2 BarBackend = 123
	began := time.Now()
	results := QueryAll("dubstep", b1, b2)
	fmt.Println(time.Since(began))
	fmt.Println(results)
}
</pre></div>

<p>
	Imagine a request/response service which should aggregate results
	from multiple backends.
	<br/><br/>
	First, mock out some "backends", which take some time to provide a result.
	<br/><br/>
	Then, make simple sequential queries over them.
	The results are aggregated and returned to the user.
	(<a href="http://code.google.com/p/go-tour/source/browse/talks/2012-04-25-NewYorkMeetup/index.html#676">Inspiration</a>.)
	<br/><br/>
	This is the most naïve way of making a search.
	Which is a good way to start!
</p>
</div>

<!-- - - - - - -->

<div class="step slide code" data-x="3000" data-y="1000">
<h1>Query v2</h1>

<div><pre>
func QueryAllConcurrent(q string, backends ...Backend) []string {
	// query
	c := make(chan string, len(backends))
	for _, backend := range backends {
		// why do I need to explicitly pass 'backend' to the function?
		go func(b Backend) { c <- b.Query(q) }(backend)
	}

	// aggregate
	results := []string{}
	for i := 0; i < cap(c); i++ {
		results = append(results, <-c)
	}
	return results
}
</pre></div>

<p>
	Of course, naïve is not ideal.
	Why can't both backends be processing queries at the same time?
	<br/><br/>
	We can make this code concurrent pretty easily.
	Think in terms of goroutines and channels.
	Each query can execute in a separate goroutine, and the result fed into
	a channel.
	The "calling" goroutine can aggregate the results from that channel.
	It looks like this.
	<br/><br/>
	<em>No</em> explicit synchronization.
	<em>No</em> explicit cleanup.
	<em>No</em> changes to the API;
	all the asynchronous stuff is handled inside a synchronous function.
</p>
</div>

<!-- - - - - - -->

<div class="step slide code" data-x="4500" data-y="1000">
<h1>Query v3</h1>

<pre>
type BackendGroup []Backend

func (g BackendGroup) QueryAllTakeFirst(q string) string {
	c := make(chan string, len(g))
	for _, backend := range g {
		go func(b Backend) { c <- b.Query(q) }(backend)
	}
	return <-c // what happens to the other goroutines?
}

func QueryReplicas(q string, groups ...BackendGroup) []string {
	// query
	c := make(chan string, len(groups))
	for _, group := range groups {
		go func(g BackendGroup) { c <- g.QueryAllTakeFirst(q) }(group)
	}

	// aggregate
	results := []string{}
	for i := 0; i < cap(c); i++ {
		results = append(results, <-c)
	}
	return results
}

func main() {
	// ...
	g1 := BackendGroup{FooBackend("abc"), FooBackend("def")}
	g2 := BackendGroup{BarBackend(123), BarBackend(456), BarBackend(789)}
	began := time.Now()
	results := QueryReplicas("dubstep", g1, g2)
}
</pre>

<p>
	Still not ideal. What if one of the backends goes down, or is slow?
	We can replicate the backends in different data centers,
	push the query to all of them, and take the first response.
	That should bring our averages down, and let us handle failures.
</p>
</div>

<!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->

<div class="step slide title" data-x="0" data-y="2000">
<h1>Example 2</h1>
<h2>Pipelined data processing</h2>
</div>

<!-- - - - - - -->

<div class="step slide visual" data-x="1500" data-y="2000">
<img src="img/placeholder.jpg" />
<p>
	We're subscribing to a message queue, converting messages
	to enriched data models, and feeding them into a data store.
</p>
</div>

<!-- - - - - - -->

<div class="step slide code" data-x="3000" data-y="2000">
<h1>Pipeline v1</h1>

<div><pre>
package main

import (
	"fmt"
	"time"
)

type Msg string

func Listen(out chan Msg) {
	rand.Seed(time.Now().UnixNano())
	for {
		time.Sleep(time.Duration(rand.Intn(100)) * time.Millisecond)
		if rand.Intn(10) < 3 {
			out <- "foo"
		} else {
			out <- "bar"
		}
	}
}

func Enrich(in, out chan Msg) {
	for {
		msg := <-in
		msg = "☆" + msg + "☆"
		out <- msg
	}
}

func Store(in chan Msg) {
	for {
		msg := <-in
		fmt.Println(msg) // mock storage
	}
}

func main() {
	toEnricher := make(chan Msg)
	toStore := make(chan Msg)

	go Listen(toEnricher)
	go Enrich(toEnricher, toStore)
	go Store(toStore)

	time.Sleep(1 * time.Second)
}
</pre></div>

<p>
	Each step takes input, does its work, and forwards the output.
	Using channels to pass ownership of an event between stages makes the
	program naturally concurrent.
	It also cleanly separates the business logic from transport semantics.
	<br/><br/>
	Also, because the channels are unbuffered, you get automatic backpressure,
	which (in my experience) is generally what you want.
</p>
</div>

<!-- - - - - - -->

<div class="step slide code" data-x="4500" data-y="2000">
<h1>Pipeline v2</h1>

<div><pre>
func Filter(in, out chan Msg) {
	for {
		msg := <-in
		if msg == "bar" {
			continue // drop
		}
		out <- msg
	}
}

func main() {
	toFilter := make(chan Msg)
	toEnricher := make(chan Msg)
	toStore := make(chan Msg)

	go Listen(toFilter)
	go Filter(toFilter, toEnricher)
	go Enrich(toEnricher, toStore)
	go Store(toStore)

	time.Sleep(1 * time.Second)
}
</div></pre>

<p>
	If we want to add a new Filter stage, it's very straightforward.
	Just think in terms of the actors doing the work,
	and the channels, ie. conduits, for that work.
	It's safe and easy to abort processing of a Msg at the Filter stage.
</p>
</div>

<!-- - - - - - -->

<div class="step slide code" data-x="6000" data-y="2000">
<h1>Pipeline v3</h1>

<div><pre>
func main() {
	toFilter := make(chan Msg)
	toEnricher := make(chan Msg)
	toStore := make(chan Msg)

	go Listen(toFilter)
	go Filter(toFilter, toEnricher)
	go Enrich(toEnricher, toStore)
	go Enrich(toEnricher, toStore)
	go Enrich(toEnricher, toStore)
	go Store(toStore)

	time.Sleep(1 * time.Second)
}
</pre></div>

<p>
	If a specific pipeline stage takes longer than the others,
	we can improve overall throughput by scaling the actors for
	that backend independently.
	<br/><br/>
	Channel operations are a synchronization point across goroutines,
	so multiple goroutines may safely read from, or write to, the same channel.
	Each sent message will be delivered to precisely one receiver.
</p>
</div>

<!-- - - - - - -->

<div class="step slide code" data-x="7500" data-y="2000">
<h1>Pipeline v4</h1>

<div><pre>
import (
	"net/http" // production-grade HTTP server
)

type Msg struct {
	Req    *http.Request
	MyData string
	Resp   http.ResponseWriter
	Done   chan bool // signal channel
}

func Listen(out chan Msg) {
	http.HandleFunc("/endpoint", func(r *http.Request, w http.ResponseWriter) {
		msg := Msg{
			Req:    r,
			MyData: r.URL.Query().Get("data"),
			Resp:   w,
		}
		out <- msg
		<-msg.Done // wait for done signal (why do we need to do this?)
	})
	http.ListenAndServe("0.0.0.0:8080", nil) // blocks
}

// ...

func Filter(in, out chan Msg) {
	for {
		msg := <-in
		if msg.MyData == "bar" {
			msg.Done <- true // signal to handler
			continue         // loop for next Msg
		}
		out <- msg
	}
}

// ...

func Store(in chan Msg) {
	for {
		msg := <-in
		fmt.Println(msg.MyData) // mock storage
		msg.Done <- true        // signal to handler
	}
}
</pre></div>

<p>
	What if our producer isn't a message queue, but instead a HTTP server?
	What if every message is an HTTP request?
	Do we need to do anything special?
	<br/><br/>
	Not really. Just change the listener and the Msg type.
</p>
</div>

<!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->

<div class="step slide title" data-x="0" data-y="3000">

<table cellpadding=35>
<tr><td colspan="3" align="center"><h1>Thanks!</h1></td></tr>
<tr>
	<td>
		<h2>@peterbourgon</h2>
	</td>
	<td>
		<a href="http://soundcloud.com">
			<img src="img/soundcloud.png" alt="SoundCloud" />
		</a>
	</td>
	<td>
		<a href="http://golang.org">
			<img src="img/golang.png" alt="Golang" />
		</a>
	</td>
</tr>
</table>

</div>

<!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->

</div><!--c-->
</div><!--impress-->

<div class="overlay"><a id="text-button" href="#">Notes</a></div>

<script src="impress.js"></script>
<script>impress().init();</script>
<script>
	$("#text-button").click(function() {
		$(".visual h1").toggle();
		$(".visual h2").toggle();
		$(".visual h3").toggle();
		$(".visual p").toggle();
		$(".code h1").toggle();
		$(".code h2").toggle();
		$(".code h3").toggle();
		$(".code p").toggle();
	});
</script>
</body>
</html>
