<!DOCTYPE html>
<html>
<head>
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<title>Go Do</title>
<link href="http://fonts.googleapis.com/css?family=Lato:400,900|Averia+Libre:300" rel="stylesheet" type="text/css" />
<link href="presentation.css" rel="stylesheet" type="text/css" />
<script type="text/javascript" src="http://ajax.googleapis.com/ajax/libs/jquery/1.7/jquery.min.js"></script>
</head>

<body class="impress-not-supported">

<div id="c">
<div id="impress">

<!-- - - - - - -->

<div class="step slide title" data-x="0" data-y="-1000">
<h1>Go Do</h1>
<h2>Peter Bourgon</h2>
</div>

<!-- - - - - - -->

<div class="step slide title" data-x="1500" data-y="-1000">
<h1>Software engineering</h1>

<p>
	is concerned with <strong>developing</strong> and
	<strong>maintaining</strong> software systems that behave reliably and
	efficiently, are affordable to develop and maintain, and satisfy all the
	requirements that customers have defined for them.
</p>

<p style="font-style:italic; margin-left:34px;">
&mdash;<a href="http://computingcareers.acm.org/?page_id=12">ACM</a>
</p>

</div>

<!-- - - - - - -->

<div class="step slide visual" data-x="3000" data-y="-1000">
<img src="img/placeholder.jpg" />

<p>
	I think of developing and maintaining as processes.
	In both cases, I'm looking at the system as it exists now,
	and comparing that against how the system should exist in the ideal case.
	And the better I am at what I do, the better I can perform that transformation.
</p>

</div>

<!-- - - - - - -->

<div class="step slide" data-x="4500" data-y="-1000">

<p>
	To help us walk the line between "now" and "later", we use tools.
	<strong>I think Go is a really excellent tool.</strong>
	It provides a small set of primitives that are orthogonal to each other,
	and can be easily combined to build solutions to a large class of problems.

	Those solutions tend to be easily decomposable, testable, and maintainable.
</p>

</div>

<!-- - - - - - -->
<!-- TODO somehow better transition between ^^^ and vvv -->
<!-- - - - - - -->

<div class="step slide visual" data-x="6000" data-y="-1000">

<img src="img/placeholder.jpg" />

<p>
	Because the primitives are so powerful, solving a problem
	<em>correctly</em>&mdash;ie. <em>ideally</em>&mdash;is possible
	without leaning heavily on libraries or frameworks.
</p>

</div>

<!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->

<div class="step slide title" data-x="0" data-y="0">
<h1>Go in 3 minutes</h1>
</div>

<!-- - - - - - -->

<div class="step slide visual" data-x="1500" data-y="0">
<img src="img/code-editor.jpg" />
<h1>Syntax</h1>
<p>
	Some basic words about Go syntax here, just to make
	the subsequent slides more readable.
	Every CODE EDITOR slide will have an editable-and-runnable
	program demonstrating the described concepts.
</p>
</div>

<!-- - - - - - -->

<div class="step slide visual" data-x="3000" data-y="0">
<img src="img/code-editor.jpg" />
<h1>Types</h1>
<p>
	Types are concrete things which may be defined by the user via
	the 'type' keyword. Commonly structs, but also aliases.
	Note that 'type' always defines a new (ie. distinct) type,
	which is not interchangable with the thing it's based on.
</p>
</div>

<!-- - - - - - -->

<div class="step slide visual" data-x="4500" data-y="0">
<img src="img/code-editor.jpg" />
<h1>Interfaces</h1>
<p>
	Interfaces specify behavior:
	"if something can do <em>this</em>, then it can be used <em>here</em>".

	Similar to an abstract class in Java.
	They operate in the behavior domain, rather than the implementation domain.

	Concrete types which implement all of an interface's methods
	<em>implement</em> that interface.

	Interfaces are first-class citizens in Go.
	Most standard-library functions take interfaces as parameters.
</p>
</div>

<!-- - - - - - -->

<div class="step slide visual" data-x="6000" data-y="0">
<img src="img/code-editor.jpg" />
<h1>Goroutines</h1>
<p>
	Goroutines are essentially coroutines,
	from Tony Hoare's
	<a href="http://en.wikipedia.org/wiki/Communicating_sequential_processes">
		Communicating Sequential Processes
	</a>.
	Like very lightweight threads; multiplexed onto operating system threads.
	Launch any function call in a new goroutine with the 'go' keyword.
	You don't get handles, or any explicit management of goroutines.
</p>
</div>

<!-- - - - - - -->

<div class="step slide visual" data-x="7500" data-y="0">
<img src="img/code-editor.jpg" />
<h1>Channels</h1>
<p>
	Communication between goroutines is idiomatically accomplished
	with channels, which are typed, synchronized, and optionally-
	buffered pipes for data.
	<br/><br/>
	"Don't communicate by sharing memory; share memory by communicating."
</p>
</div>

<!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->

<div class="step slide title" data-x="0" data-y="1000">
<h1>Example 1</h1>
<h2>Aggregating data from multiple backends</h2>
</div>

<!-- - - - - - -->

<div class="step slide visual" data-x="1500" data-y="1000">
<img src="img/code-editor.jpg" />
<p>
	Imagine a request/response service which should aggregate results
	from multiple backends.
	Mock out a "backend", which takes some time to provide a result.
	Then, make simple sequential queries over three of them.
	The results are aggregated and returned to the user.
	(<a href="http://code.google.com/p/go-tour/source/browse/talks/2012-04-25-NewYorkMeetup/index.html#676">inspiration</a>).

	This is the most naïve way of making a search.
	Which is a good way to start!
	<br/><br/>

<pre>
package main

import (
	"fmt"
	"math/rand"
	"time"
)

type Backend interface {
	Query(q string) string
}

type FooBackend string
func (b FooBackend) Query(q string) string {
	time.Sleep(time.Duration(rand.Intn(100)) * time.Millisecond)
	// TODO why can 'b' satisfy '%s'?
	return fmt.Sprintf("Foo:%s:%s", b, q)
}

type BarBackend int
func (b BarBackend) Query(q string) string {
	time.Sleep(time.Duration(rand.Intn(100)) * time.Millisecond)
	// TODO why can 'b' satisfy '%d'?
	return fmt.Sprintf("Bar:%d:%s", b, q)
}

func QueryAll(q string, backends ...Backend) []string {
	results := []string{}
	for _, backend := range backends {
		r := backend.Query(q)
		results = append(results, r)
	}
	return results
}

func main() {
	rand.Seed(time.Now().UnixNano())
	var b1 FooBackend = "abc"
	var b2 BarBackend = 123
	began := time.Now()
	results := QueryAll("dubstep", b1, b2)
	fmt.Println(time.Since(began))
	fmt.Println(results)
}
</pre>
</p>
</div>

<!-- - - - - - -->

<div class="step slide visual" data-x="3000" data-y="1000">
<img src="img/code-editor.jpg" />
<p>
	Of course, naïve is not ideal.
	Why can't both backends be processing queries at the same time?
	We can make this code concurrent pretty easily.
	Think in terms of goroutines and channels.
	Each query can execute in a separate goroutine, and the result fed into
	a channel.
	The "calling" goroutine can aggregate the results from that channel.
	It looks like this.
	<br/><br/>
	Note: no explicit synchronization.<br/>
	Note: no changes to the API. All the asynchronous stuff is handled
	behind a synchronous API.<br/>
	Note: no explicit cleanup.<br/>
	<br/><br/>

<pre>
func QueryAllConcurrent(q string, backends ...Backend) []string {
	// query
	c := make(chan string, len(backends))
	for _, backend := range backends {
		// why do I need to pass 'b' explicitly to the function?
		go func(b Backend) { c <- b.Query(q) }(backend)
	}

	// aggregate
	results := []string{}
	for i := 0; i < cap(c); i++ {
		results = append(results, <-c)
	}
	return results
}
</pre>
</p>
</div>

<!-- - - - - - -->

<div class="step slide visual" data-x="4500" data-y="1000">
<img src="img/code-editor.jpg" />
<p>
	Still not happy. What if one of the backends goes down, or is slow?
	We can replicate the backends in different data centers,
	push the query to all of them, and take the first response.
	That should bring our averages down, and let us handle failures.
	<br/><br/>

<pre>
type BackendGroup []Backend

func (g BackendGroup) QueryAllTakeFirst(q string) string {
	c := make(chan string, len(g))
	for _, backend := range g {
		go func(b Backend) { c <- b.Query(q) }(backend)
	}
	return <-c  // what happens to the other results?
}

func QueryReplicas(q string, groups ...BackendGroup) []string {
	// query
	c := make(chan string, len(groups))
	for _, group := range groups {
		go func(g BackendGroup) { c <- g.QueryAllTakeFirst(q) }(group)
	}

	// aggregate
	results := []string{}
	for i := 0; i < cap(c); i++ {
		results = append(results, <-c)
	}
	return results
}

func main() {
	// ...
	g1 := BackendGroup{FooBackend("abc"), FooBackend("def")}
	g2 := BackendGroup{BarBackend(123), BarBackend(456), BarBackend(789)}
	began := time.Now()
	results := QueryReplicas("dubstep", g1, g2)
}
</pre>
</p>
</div>

<!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->

<div class="step slide title" data-x="0" data-y="2000">
<h1>Example 2</h1>
<h2>Pipelined data processing</h2>
</div>

<!-- - - - - - -->

<div class="step slide visual" data-x="1500" data-y="2000">
<img src="img/placeholder.jpg" />
<p>
	We're subscribing to a message queue, converting messages
	to enriched data models, and feeding them into a data store.
</p>
</div>

<!-- - - - - - -->

<div class="step slide visual" data-x="3000" data-y="2000">
<img src="img/code-editor.jpg" />
<p>
	Break each step of the process apart, into simple,
	synchronous functions. We will manage the motion of data
	in a separate conceptual layer.
</p>
</div>

<!-- - - - - - -->

<div class="step slide visual" data-x="4500" data-y="2000">
<img src="img/code-editor.jpg" />
<p>
	Using channels to pass ownership of a request
	between pipeline stages makes the program
	naturally concurrent.

	It also cleanly separates concerns: business logic,
	error handling, scaling for performance.
</p>
</div>

<!-- - - - - - -->

<div class="step slide visual" data-x="6000" data-y="2000">
<img src="img/code-editor.jpg" />
<p>
	A failure at any stage of the pipeline can easily trigger
	a "failed" response to the client and terminate the request.
	The consequences of the error don't bubble any further into
	the workflow than they need to.
</p>
</div>

<!-- - - - - - -->

<div class="step slide visual" data-x="7500" data-y="2000">
<img src="img/code-editor.jpg" />
<p>
	If a specific backend takes longer to call than the others,
	we can preserve overall throughput by scaling the actors for
	that backend independently.
</p>
</div>

<!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->

<div class="step slide title" data-x="0" data-y="3000">
<h1>Thanks!</h1>
<h2>@peterbourgon</h2>
<a href="http://soundcloud.com">
	<img src="img/soundcloud.png" alt="SoundCloud" />
</a>
</div>

<!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->

</div><!--c-->
</div><!--impress-->

<div class="overlay"><a id="text-button" href="#">Notes</a></div>

<script src="impress.js"></script>
<script>impress().init();</script>
<script>
	$("#text-button").click(function() {
		$(".visual h1").toggle();
		$(".visual h2").toggle();
		$(".visual h3").toggle();
		$(".visual p").toggle();
	});
</script>
</body>
</html>
