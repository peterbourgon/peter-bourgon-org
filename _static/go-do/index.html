<!DOCTYPE html>
<html>
<head>
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<title>Go Do</title>
<link href="http://fonts.googleapis.com/css?family=Lato:400,900|Averia+Libre:300" rel="stylesheet" type="text/css" />
<link href="presentation.css" rel="stylesheet" type="text/css" />
<script type="text/javascript" src="http://ajax.googleapis.com/ajax/libs/jquery/1.7/jquery.min.js"></script>
</head>

<body class="impress-not-supported">

<div id="c">
<div id="impress">

<!-- - - - - - -->

<div class="step slide title" data-x="0" data-y="-1000">
<h1>Go Do</h1>
<h2>Peter Bourgon</h2>
</div>

<!-- - - - - - -->

<div class="step slide title" data-x="1500" data-y="-1000">
<h1>Software engineering</h1>

<p>
	is concerned with <strong>developing</strong> and
	<strong>maintaining</strong> software systems that behave reliably and
	efficiently, are affordable to develop and maintain, and satisfy all the
	requirements that customers have defined for them.
</p>

<p style="font-style:italic; margin-left:34px;">
&mdash;<a href="http://computingcareers.acm.org/?page_id=12">ACM</a>
</p>

</div>

<!-- - - - - - -->

<div class="step slide visual" data-x="3000" data-y="-1000">
<img src="img/placeholder.jpg" />

<p>
	I think of developing and maintaining as processes.
	In both cases, I'm looking at the system as it exists now,
	and comparing that against how the system should exist in the ideal case.
	And the better I am at what I do, the better I can perform that transformation.
</p>

</div>

<!-- - - - - - -->

<div class="step slide" data-x="4500" data-y="-1000">

<p>
	To help us walk the line between "now" and "later", we use tools.
	<strong>I think Go is a really excellent tool.</strong>
	It provides a small set of primitives that are orthogonal to each other,
	and can be easily combined to build solutions to a large class of problems.

	Those solutions tend to be easily decomposable, testable, and maintainable.
</p>

</div>

<!-- - - - - - -->
<!-- TODO somehow better transition between ^^^ and vvv -->
<!-- - - - - - -->

<div class="step slide visual" data-x="6000" data-y="-1000">

<img src="img/placeholder.jpg" />

<p>
	Because the primitives are so powerful, solving a problem
	<em>correctly</em>&mdash;ie. <em>ideally</em>&mdash;is possible
	without leaning heavily on libraries or frameworks.
</p>

</div>

<!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->

<div class="step slide title" data-x="0" data-y="0">
<h1>Go in 3 minutes</h1>
</div>

<!-- - - - - - -->

<div class="step slide visual" data-x="1500" data-y="0">
<img src="img/code-editor.jpg" />
<h1>Syntax</h1>
<p>
	Some basic words about Go syntax here, just to make
	the subsequent slides more readable.
	Every CODE EDITOR slide will have an editable-and-runnable
	program demonstrating the described concepts.
</p>
</div>

<!-- - - - - - -->

<div class="step slide visual" data-x="3000" data-y="0">
<img src="img/code-editor.jpg" />
<h1>Types</h1>
<p>
	Types are concrete things which may be defined by the user via
	the 'type' keyword. Commonly structs, but also aliases.
	Note that 'type' always defines a new (ie. distinct) type,
	which is not interchangable with the thing it's based on.
</p>
</div>

<!-- - - - - - -->

<div class="step slide visual" data-x="4500" data-y="0">
<img src="img/code-editor.jpg" />
<h1>Interfaces</h1>
<p>
	Interfaces specify behavior:
	"if something can do <em>this</em>, then it can be used <em>here</em>".

	Similar to an abstract class in Java.
	They operate in the behavior domain, rather than the implementation domain.

	Concrete types which implement all of an interface's methods
	<em>implement</em> that interface.

	Interfaces are first-class citizens in Go.
	Most standard-library functions take interfaces as parameters.
</p>
</div>

<!-- - - - - - -->

<div class="step slide visual" data-x="6000" data-y="0">
<img src="img/code-editor.jpg" />
<h1>Goroutines</h1>
<p>
	Goroutines are essentially coroutines,
	from Tony Hoare's
	<a href="http://en.wikipedia.org/wiki/Communicating_sequential_processes">
		Communicating Sequential Processes
	</a>.
	Like very lightweight threads; multiplexed onto operating system threads.
	Launch any function call in a new goroutine with the 'go' keyword.
	You don't get handles, or any explicit management of goroutines.
</p>
</div>

<!-- - - - - - -->

<div class="step slide visual" data-x="7500" data-y="0">
<img src="img/code-editor.jpg" />
<h1>Channels</h1>
<p>
	Communication between goroutines is idiomatically accomplished
	with channels, which are typed, synchronized, and optionally-
	buffered pipes for data.
	<br/><br/>
	"Don't communicate by sharing memory; share memory by communicating."
</p>
</div>

<!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->

<div class="step slide title" data-x="0" data-y="1000">
<h1>Example 1</h1>
<h2>Aggregating data from multiple backends</h2>
</div>

<!-- - - - - - -->

<div class="step slide visual" data-x="1500" data-y="1000">
<img src="img/code-editor.jpg" />
<p>
	Imagine a service which should provide a simple API to make
	queries against a social graph.
</p>
</div>

<!-- - - - - - -->

<div class="step slide visual" data-x="3000" data-y="1000">
<img src="img/code-editor.jpg" />
<p>
	Of course, we will soon want to extend the API.
</p>
</div>


<!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->

<div class="step slide title" data-x="0" data-y="2000">
<h1>Example 2</h1>
<h2>Pipelined data processing</h2>
</div>

<!-- - - - - - -->

<div class="step slide visual" data-x="1500" data-y="2000">
<img src="img/placeholder.jpg" />
<p>
	We're subscribing to a message queue, converting messages
	to enriched data models, and feeding them into a data store.
</p>
</div>

<!-- - - - - - -->

<div class="step slide visual" data-x="3000" data-y="2000">
<img src="img/code-editor.jpg" />
<p>
	Break each step of the process apart, into simple,
	synchronous functions. We will manage the motion of data
	in a separate conceptual layer.
</p>
</div>

<!-- - - - - - -->

<div class="step slide visual" data-x="4500" data-y="2000">
<img src="img/code-editor.jpg" />
<p>
	Using channels to pass ownership of a request
	between pipeline stages makes the program
	naturally concurrent.

	It also cleanly separates concerns: business logic,
	error handling, scaling for performance.
</p>
</div>

<!-- - - - - - -->

<div class="step slide visual" data-x="6000" data-y="2000">
<img src="img/code-editor.jpg" />
<p>
	A failure at any stage of the pipeline can easily trigger
	a "failed" response to the client and terminate the request.
	The consequences of the error don't bubble any further into
	the workflow than they need to.
</p>
</div>

<!-- - - - - - -->

<div class="step slide visual" data-x="7500" data-y="2000">
<img src="img/code-editor.jpg" />
<p>
	If a specific backend takes longer to call than the others,
	we can preserve overall throughput by scaling the actors for
	that backend independently.
</p>
</div>

<!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->

<div class="step slide title" data-x="0" data-y="3000">
<h1>Thanks!</h1>
<h2>@peterbourgon</h2>
<a href="http://soundcloud.com">
	<img src="img/soundcloud.png" alt="SoundCloud" />
</a>
</div>

<!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->

</div><!--c-->
</div><!--impress-->

<div class="overlay"><a id="text-button" href="#">Notes</a></div>

<script src="impress.js"></script>
<script>impress().init();</script>
<script>
	$("#text-button").click(function() {
		$(".visual h1").toggle();
		$(".visual h2").toggle();
		$(".visual h3").toggle();
		$(".visual p").toggle();
	});
</script>
</body>
</html>
