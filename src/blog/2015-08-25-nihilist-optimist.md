{ "title": "The nihilist and optimst programmers" }
---
The nihilist programmer takes as axiomatic that their product is already
broken. It is in constant flux, poorly defined, the product of compromise in
design, and inevitably compromised in implementation. Even more, that it will
remain this way, by its nature, forever. The nihilist programmer starts from
these axioms and then decides what to do. What to do? The least amount of
change possible. Limit exposure, limit effect. Get to the next checkpoint.

The particular medicine isn't a bad one, _per se_. There's value in those
limits. What's bad, I think, is the ethos. If a thing is undefinable, you will
naturally resist efforts to define it. If a thing is forever in flux, you will
resist efforts to freeze it. If a thing is composed exclusively of compromise,
you will resist efforts to make decisive decisions. And if a thing will never
be good, you will resist efforts to make it good.

In this sense the nihilist programmer ensures their travels on a dead-end road
are as comfortable, and perhaps long-lived, as possible.

The optimist programmer, in contrast, seeks to change course.

The optimist programmer assumes the thing can be good, and constantly
initiates to make it good. That the thing shouldn't contain compromise, and
should reflect clear decisions. That the thing should be defined and then
built, and not rock forever on a sea of changing assumptions. That the thing
ought _rightly be defined_, that its true form is definitional.

What's bad about the optimist programmer isn't the ethos, but the practice. In
reality, nothing is fixed, and everything is in flux. By straining to define
and then build, the optimist programmer inevitably builds the wrong thing. Or,
perhaps more often, nothing at all, as the thing never escapes the design
stage.

Successful projects live somewhere in the middle. But I think all good
software is fundamentally optimistic. Not that it won't contain compromise, or
technical debt to be repaid, but that it doesn't start from the assumption
that nothing is definite and all hope is lost. Optimistic software makes
decisive claims, executes on them, and owns the compromises it makes.
Optimistic software can be critiqued for doing the wrong thing, but not for
doing it poorly. I am an optimist programmer and I want to write optimistic
software.
