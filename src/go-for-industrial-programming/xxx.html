<!DOCTYPE html>
<html>

<head>
	<title>Go: Best Practices for Industrial Programming</title>
	<style>
		.present-only {
			display: none;
		}

		.present-only.present {
			display: block;
		}

		.no-present.present {
			display: none;
		}

		body {
			font-size: 14pt; /*16pt;*/
			line-height: 1.6em; /*1.4em;*/
			margin-bottom: 10em;
		}

		body.present {
			zoom: 2;
		}

		div#present-button {
			position: fixed;
			bottom: 0;
			right: 0;
			margin: 1em;
			z-index: 999;
			padding: 0 5px;
			cursor: pointer;
			background-color: #fff;
			border: solid 1px #000;
		}

		div#present-button.present {
			font-style: italic;
			border: solid 1px #ccc;
			color: #ccc;
			font-size: 50%;
			line-height: 1.3em;
		}

		div.slide {
			/*max-width: 600px;
			margin: 0 20%;*/
			min-width: 20em;
			max-width: 40em;
			margin: 0 15%;
		}

		div.slide.present {
			max-width: 100%;
			margin: 2em;
			padding: 0 1em;
			height: 50vh;
			border-top: solid 1px #333;
		}

		/*p {
			display: inline;
		}*/

		p.present {
			display: none;
		}

		p.present-only.present {
			margin-top: -0.3em;
		}

		pre {
			font-size: 11pt;
			padding: 1em;
			border-top: solid 1px #ccc;
			border-bottom: solid 1px #ccc;
			line-height: 1.2em;
			margin: 2em -6em 2em -3em;
		}

		pre.present {
			border: none;
			margin: 1em;
			font-size: 8pt;
			line-height: 1.5em;
		}

		/*ul {
			
		}*/

		ul.present {
			display: none;
		}

		ul.present.opt-in {
			display: inherit;
		}

		ul.present.opt-in a {
			text-decoration: none;
		}

		/*ol {

		}*/

		ol.present {
			display: none;
		}

		ol.present.opt-in { 
			display: inherit;
		}

		ol.present.opt-in a {
			text-decoration: none;
		}

		h1 {
			line-height: 1.3em;
		}

		h2 {
			line-height: 1em;
			font-style: italic;
			margin-top: 2em;
		}

		h2::before {
			/* this fixes the hash links from headbutting the top of the window */
			display: block;
			content: " ";
			margin-top: -0.5em;
			height: 0.5em;
			visibility: hidden;
			pointer-events: none;
		}

		h2.present {
			font-size: 25pt;
			margin: 1em 0;
		}

		/*h3 {
			
		}*/

		h3::before {
			display: block;
			content: " ";
			margin-top: -1em;
			height: 1em;
			visibility: hidden;
			pointer-events: none;
		}

		h3.present {
			font-size: 18pt;
			line-height: 1em;
		}

		img {
			margin: 1em;
		}

		img.push-right {
			float: right;
			margin-right: -150px;
		}

		img.push-left {
			float: left;
			margin-left: -100px;
		}

		/* -- */
		img.class01 {
			width: 250px;
		}

		img.class01.present {
			float: left;
			width: 500px;
			max-width: 75%;
			margin: 1em 0;
		}

		/* -- */
		img.class02 {
			width: 280px;
		}

		img.class02.present {
			float: left;
			max-height: 60%;
			margin: 1em 1em;
		}

		img.present {
			width: inherit;
			height: inherit;
			float: none;
			margin: 2em 1em 1em 1em;
		}

		a {
			color: inherit;
		}

		a:visited {
			color: inherit;
		}

		blockquote {
			margin: 1em 2em;
		}

		blockquote.present {
			display: none;
		}

		table {
			margin: 0;
			width: 82%;
		}

		table.present {
			width: 80%;
			margin: 1em 1em 1em 0;
		}

		th.top {
			text-align: center;
		}

		th.left {
			text-align: right;
		}

		td {
			text-align: center;
			background-color: pink;
			margin: 0.2em 1em;
			
		}

		td.low {
			background-color: rgba(0, 255, 0, 0.33);
		}

		td.medium {
			background-color: rgba(255, 255, 0, 0.33);
		}

		td.high {
			background-color: rgba(255, 0, 0, 0.33);
		}

		h1 > a, h2 > a, h3 > a {
			text-decoration: none;
		}

		.pad {
			padding: 0.2em 0.5em 0.1em 0.5em;
		}

		.rotate_1deg {
			transform: rotate(1.0deg);
		}

		.rotate_n1deg {
			transform: rotate(-1deg);
		}

		.shade_red {
			background-color: rgba(232, 10, 10, 0.3);
		}

		.shade_green {
			background-color: rgba(45, 255, 45, 0.3);
		}

		.shade_blue {
			background-color: rgba(0, 0, 255, 0.3);
		}

		.shade_purple {
			background-color: rgba(200, 32, 200, 0.3);
		}

		.shade_orange {
			background-color: rgba(255, 135, 29, 0.3);
		}
	</style>
	<script src="jquery.min.js"></script>
</head>

<body class="variable">
	<div id="present-button" class="variable">Present</div>

	<div id="c">
		<div class="variable slide">
			<h1 class="variable rotate_n1deg"><span class="shade_red">Go: Best Practices for Industrial Programming</span></h1>
			<h2 class="variable present-only">Peter Bourgon</h2>
			<h3 class="variable present-only">GopherCon Europe &bull; June 2018</h3>
		</div>

		<div class="variable slide">
			<h2 class="variable rotate_1deg">
				<span class="pad shade_green">
					Setting some context
				</span>
			</h2>
		</div>
		<div class="variable slide">
			<a href="https://twitter.com/rakyll/status/869762601642799104">
				<img src="rakyll.png" alt="Don't blindly apply advice." class="variable class01 push-right" />
			</a>
			<p class="variable">
				So I'm actually in a bit of a strange situation right now. And I think everyone who takes the stage here,
				or at any conference, is in the same sort of bind.
			</p>
			<p class="variable">
				<a href="https://twitter.com/rakyll/status/869762601642799104">The inimitable JBD has given</a>
				us the professional tip that we should never blindly apply dogmatic advice, and that we should use our
				judgment each and every time. Presumably also with that selfsame tip. But I have applied my judgment
				to this statement, and I judge it to be true.
			</p>
		</div>

		<div class="variable slide">
			<a href="https://twitter.com/holman/status/951277187067404288">
				<img src="holman.png" alt="Well, it depends." class="variable class01 push-left" />
			</a>
			<p class="variable">
				<a href="https://twitter.com/holman/status/951277187067404288">Some guy on the internet</a>
				has additionally observed that the longer it is you're in the tech industry the more your opinions end
				up being
				<em>well it depends</em> and
				<em>I'm not sure</em> and that these don't quite make for good talks. That also feels true to me&mdash;at
				least, if you're doing things right. It's my experience that if you find that you're getting more
				strongly opinionated as you advance in your career, chances are you're caught in a rut and becoming
				an expert beginner. Not great!
			</p>
		</div>

		<div class="variable slide">
			<h3 class="variable present-only">
				Paralysis!
			</h3>
			<p class="variable">
				Taken together, these two truths about advice-giving seem to push us into a paralysis. The more experienced
				I become, the less sure I am about anything, and the less likely I am to deliver actionable advice
				to you, the audience. And the better you are at receiving advice, the less likely you are to believe
				what I say. So what am I even doing up here? Should we all go home?
			</p>
		</div>

		<div class="variable slide">
			<p class="variable">
				&mdash;
			</p>
			<p class="variable">
				To break out of this paralysis I think we can employ a couple of strategies. First, we can ensure that
				when we give advice, we place it into the specific
				<em>context</em> where it makes sense. If we can define an explicit scope of applicability, we can carve
				out a little space for ourselves to have a well-defined opinion.
			</p>
			<h3 class="variable present-only">
				Strategy 1:
				<br/>Always provide specific
				<em>context</em>
			</h3>
		</div>

		<div class="variable slide">
			<p class="variable">
				That's what I've tried to do with the title of the talk. I'm speaking today about programming in an industrial
				context. By that I mean
			</p>
			<h3 class="variable present-only">
				Industrial Programming is (maybe)...
			</h3>
			<ul class="variable opt-in">
				<li>in a startup or corporate environment;</li>
				<li>within a team where engineers come and go;</li>
				<li>on code that outlives any single engineer; and</li>
				<li>serving highly mutable business requirements.</li>
			</ul>
			<p class="variable">
				This describes my work environments for most recent memory. I suspect it does for a lot of you, too.
				And the best advice for Go in this context is sometimes different than for Go in personal projects,
				or large open-source libraries, and so on.
			</p>
		</div>

		<div class="variable slide">
			<p class="variable">
				And to speak to JBD's point, I should be careful to always
				<em>justify</em> the advice I give, so that you can follow the chain of reasoning yourself, and draw
				your own conclusions. I've tried my best to do that in this talk.
			</p>
			<h3 class="variable present-only">
				Strategy 2:
				<br/> Always provide sufficient
				<em>justification</em>
			</h3>
		</div>

		<div class="variable slide">
			<p class="variable">
				So with those guidelines in mind, let's review the set of topics I'd like to try to cover. I've tried
				to select for areas that have routinely tripped up new and intermediate Gophers in organizations
				I've been a part of, and particularly those things that may have nonobvious or subtle implications.
			</p>
			<h3 class="variable present-only">
				Table of Contents
			</h3>
			<ol class="variable opt-in">
				<li>
					<a href="#structuring-your-code-and-repository">Structuring your code and repository</a>
				</li>
				<li>
					<a href="#program-configuration">Program configuration</a>
				</li>
				<li>
					<a href="#the-component-graph">The component graph</a>
				</li>
				<li>
					<a href="#goroutine-lifecycle-management">Goroutine lifecycle management</a>
				</li>
				<li>
					<a href="#observability">Observability</a>
				</li>
				<li>
					<a href="#testing">Testing</a>
				</li>
				<li>
					<a href="#how-much-interface-do-i-need">How much interface do I need?</a>
				</li>
				<li>
					<a href="#context-use-and-misuse">Context use and misuse</a>
				</li>
			</nl>
		</div>

		<div class="variable slide">
			<a name="structuring-your-code-and-repository">
				<h2 class="variable rotate_n1deg">
						<a class="pad shade_purple" href="#structuring-your-code-and-repository">Structuring your code and repository</a>
				</h2>
			</a>
			<p class="variable">
				One thing I see frequently among my colleagues, especially those very new to Go, is an expectation of
				a rigid project structure, often decided
				<em>a priori</em> at the start of the project. I think this is generally more problematic than helpful.
				To understand why, remember the fourth, and maybe most important, property of industrial programming:
				<blockquote class="variable">
					Industrial programming ... serves
					<strong>highly mutable business requirements</strong>
				</blockquote>
			</p>
			<p class="variable present-only">
				Industrial programming serves highly mutable business requirements:
			</p>
			<h3 class="variable present-only">
				Don't opt in to structure before you need it
			</h3>
			<p class="variable">
				The only constant is change, and
				<a href="https://medium.com/@rdsubhas/10-modern-software-engineering-mistakes-bc67fbef4fc8">the only rule of business requirements</a>
				is that they never converge, they only diverge, grow, and mutate. So we should make sure our code accommodates
				this fact of life, and not box ourselves in unnecessarily. Our repos, our abstractions, our code
				itself should be easy to maintain by being easy to change, easy to adapt, and, ultimately,
				<a href="https://programmingisterrible.com/post/139222674273/write-code-that-is-easy-to-delete-not-easy-to">easy to delete</a>.
			</p>
			<p class="variable">
				There are a few things that are generally good ideas. If your project has multiple binaries, it's a good
				idea to have a cmd/ subdirectory to hold them. If your project is large and has significant non-Go
				code, like UI assets or sophisticated build tooling, it might be a good idea to keep your Go code
				isolated in a pkg/ subdirectory. If you're going to have multiple packages, it's probably a good
				idea to orient them around the business domain, rather than around accidents of implementation. That
				is: package user, yes; package models, no. There are a couple of good articles for package design:
				<a href="https://medium.com/@benbjohnson/standard-package-layout-7cdbc8391fc1">Ben Johnson's Standard Package Layout</a>
				and
				<a href="https://talks.bjk.fyi/bketelsen/gcru18-best#/">Brian Ketelsen's GopherCon Russia talk</a>
				this year had some good advice.
			</p>
			<p class="variable">
				Of course, business domain and implementation are not always
				<!--<a href="https://gobuffalo.io/en/docs/directory-structure">
					<img src="gobuffalo-doc.png" class="variable class01 push-right" />
				</a>-->
				strictly separated. For example, large web applications tend to intermingle transport and core business
				concerns. Frameworks like
				<a href="https://gobuffalo.io/en">GoBuffalo</a>
				encourage package names like actions, assets, models, and templates. When you know you're dealing with
				HTTP exclusively,
				<a href="https://twitter.com/thockin/status/958606077456654336">
					<img src="thockin.png" class="variable class01 push-left" style="" />
				</a>
				there are advantages to going all-in on the coupling.
			</p>
			<p class="variable">
				Tim Hockin also suggests we align packages on dependency
				boundaries. That is, have separate packages for e.g. RedisStore,
				MySQLStore, etc. to avoid external consumers having to include
				and compile support for things they don't need. In my opinion,
				this is an inappropriate optimization for packages with a closed
				set of importers, but makes a lot of sense for packages widely
				imported by third parties, like Kubernetes, where the size of
				the compilation unit can become a real bottleneck.
			</p>
			<p class="variable">
				So there's a spectrum of applicability. I think the best general
				advice is to only opt-in to a bit of structure once you feel the
				need, concretely. Most of my projects still start out as a few
				files in package main, bundled together at the root of the repo.
				And they stay that way until they become at least a couple
				thousand lines of code. Many, even most, of my projects never
				make it that far. One nice thing about Go is that it can feel
				very lightweight; I like to preserve that as long as possible.
			</p>
		</div>

		<div class="variable slide">
			<a name="program-configuration">
				<h2 class="variable rotate_1deg">
					<a class="pad shade_blue" href="#program-configuration">Program configuration</a>
				</h2>
			</a>
			<p class="variable">
				I feel like I say this in almost every talk I give or article I
				write, but I wouldn't want to break the streak now, so let me
				repeat myself:
				<strong>Flags are the best way to configure your program</strong>, 
				because they're a self-documenting way to describe the configuration surface area of your
				program at runtime.
			</p>
			<h3 class="variable present-only">
				Flags are the best way to configure your program
			</h3>
			<p class="variable present-only">
				They self-document the configuration surface area at runtime
			</p>
		</div>

		<div class="variable slide">
			<p class="variable">
				This is particularly important in industrial contexts, where whoever is operating a service may not be
				its original author. If running your program with the -h flag provides a complete list of the knobs
				and switches that controls its behavior, then it's very easy for an on-call engineer to adjust something
				during an incident, or for a new engineer to get it running in their dev environment. Much easier
				than having to hunt down a set of relevant environment variables in (probably outdated) documentation,
				or figure out the syntax and valid key names of a config file format.
			</p>
			<p class="variable">
				This doesn't mean never use env vars or config files. There are
				good reasons to use either or both
				<em>in addition to</em>
				flags. Env vars can be useful for connection strings and
				non-secret auth tokens, especially during dev. And config files
				are great for declaring verbose configs, as well as being the
				only secure way to get secrets into a program. (Both env vars
				and flags can be inspected by other users of the system at
				runtime.) Just ensure that explicit commandline flags, if given,
				take highest priority. 
			</p>
			<h3 class="variable present-only">
				Env vars and config files are useful
				<em>in addition to</em> flags
			</h3>
			<p class="variable present-only">
				Avoid using them as the <em>only</em>
				way to configure your program
			</p>
		</div>

		<div class="variable slide">
			<p class="variable">
				&mdash;
			</p>
			<p class="variable">
				I've speculated in the past about a theoretical configuration
				package which mandated the use of flags for config, but also
				allowed env vars and config files in various formats, on an
				opt-in basis. I have strong opinions about what that package
				should look like, but haven't yet spent the time to implement
				it. Maybe I can put this out there as a package request?
			</p>
			<pre class="variable">
var fs myflag.FlagSet
var (
	foo = fs.String("foo", "x", "foo val")
	bar = fs.String("bar", "y", "bar val", myflag.JSON("bar"))
	baz = fs.String("baz", "z", "baz val", myflag.JSON("baz"), myflag.Env("BAZ"))
	cfg = fs.String("cfg", "", "JSON config file")
)
fs.Parse(os.Args, myflag.JSONVia("cfg"), myflag.EnvPrefix("MYAPP_"))
</pre>
		</div>

		<div class="variable slide">
			<a name="the-component-graph">
				<h2 class="variable rotate_n1deg">
					<a class="pad shade_orange" href="#the-component-graph">The component graph</a>
				</h2>
			</a>
			<p class="variable">
				Industrial programming means writing code once and maintaining it into perpetuity. Maintenance is the
				continuous practice of reading and refactoring. Therefore, industrial programming overwhelmingly
				favors reads, and on the spectrum of
				<em>easy to read</em> vs. <em>easy to write</em>, 
				we should bias strongly towards the former.
			</p>
			<h3 class="variable present-only">
				Prefer inversion-of-control dependency injection
			</h3>
			<p class="variable present-only">
				Avoid dependency injection frameworks or containers
			</p>
			<p class="variable">
				Dependency injection is a powerful tool to optimize for read comprehension. And here I definitely don't
				mean the dependency container approach used by
				<a href="https://github.com/facebook-go/inject">facebook-go/inject</a> or
				<a href="https://github.com/uber/dig">uber/dig</a>, but rather the much simpler practice of enumerating dependencies as parameters to types
				or constructors.
			</p>
		</div>

		<div class="variable slide">
			<h3 class="variable present-only">
				Avoid ✗
			</h3>
			<p class="variable">
				<a href="">Here's an example</a> of container-based dependency injection that recently made the rounds:
			</p>
			<pre class="variable">
func BuildContainer() *dig.Container {  
	container := dig.New()
	container.Provide(NewConfig)
	container.Provide(ConnectDatabase)
	container.Provide(NewPersonRepository)
	container.Provide(NewPersonService)
	container.Provide(NewServer)
	return container
}
	
func main() {  
	container := BuildContainer()
	if err := container.Invoke(func(server *Server) {
		server.Run()
	}); err != nil {
		panic(err)
	}
}
</pre>
			<p class="variable">
				The func main is compact, and BuildContainer has the appearance of being pithy and to-the-point. But
				the Provide method requires reflection to interpret its arguments, and Invoke gives us no clues
				as to what a Server actually needs to do its job. A new employee would have to jump between multiple
				contexts to build a mental model of each of the dependencies, how they interact, and how they're
				consumed by the server. This represents a bad tradeoff of read- vs. write-comprehension.
			</p>
		</div>

		<div class="variable slide">
			<p class="variable">
				Compare against a slightly adapted version of the code that this example is meant to improve:
			</p>
			<h3 class="variable present-only">
				Prefer ✔︎
			</h3>
			<pre class="variable">
func main() {  
	cfg := GetConfig()
	db, err := ConnectDatabase(cfg.URN)
	if err != nil {
		panic(err)
	}
	repo := NewPersonRepository(db)
	service := NewPersonService(cfg.AccessToken, repo)
	server := NewServer(cfg.ListenAddr, service)
	server.Run()
}
</pre>
			<p class="variable">
				The func main is longer, but in exchange for that length we get unambiguous explictness. Each component
				is constructed in dependency-order, with errors handled inline. Each constructor enumerates its
				dependencies as parameters, allowing new code readers to quickly and easily build a mental model
				of the relationship graph between components. Nothing is obscured behind layers of indirection.
			</p>
			<p class="variable">
				If a refactor requires a component to acquire a new dependency, it simply needs to be added to the constructor.
				The next compile will trigger errors that precisely identify the parameter lists need to be updated,
				and the diff in the resulting PR will clearly show the flow of the dependency through the graph.
			</p>
			<p class="variable">
				I claim this strictly superior to the previous method, where relationships are much harder to extract
				from the code as written, and much of the failure detection is deferred until runtime. And I claim
				it's increasingly superior as the size of the program (and the size of the func main) grows, and
				the benefits of plain and explicit initialization compound.
			</p>
		</div>

		<div class="variable slide">
			<p class="variable">
				&mdash;
			</p>
			<p class="variable">
				When we talk about read comprehension, I like to reflect on
				what I think is the single most important property of Go, which is that 
				it is essentially non-magical.
				With very few exceptions, a straight-line reading of Go code
				leaves no ambiguity about definitions, dependency relationships,
				or runtime behavior.
				This is great.
			</p>
			<p class="variable">
				But there are a few ways that magic can creep in. One
				unfortunately very common way is through the use of global
				state. Package-global objects can encode state and/or behavior
				that is hidden from external callers. Code that calls on those
				globals can have surprising side effects, which subverts the
				reader’s ability to understand and mentally model the program.
			</p>
			<p class="variable">
				Accordingly, and in deference to read-optimization and
				maintenence costs, I think the ideal Go program has little to no
				package global state, preferring instead to enumerate
				dependencies explicitly, through constructors. And since the
				only job of func init is to initialize package global state, I
				think it's best understood as a serious red flag in almost any
				program. I've programmed this way for many years, and I've only
				grown to appreciate and advocate for the practice more strongly
				in that time.
			</p>
			<p class="variable">
				So,
				<a href="https://peter.bourgon.org/blog/2017/06/09/theory-of-modern-go.html">my theory of modern Go</a>:
			</p>
			<h3 class="variable present-only">
				My theory of modern Go
			</h3>
			<ul>
				<li>No package level variables</li>
				<li>No func init</li>
			</ul>
		</div>

		<div class="variable slide">
			<a name="goroutine-lifecycle-management">
				<h2 class="variable rotate_1deg">
					<a class="pad shade_purple" href="#goroutine-lifecycle-management">Goroutine lifecycle management</a>
				</h2>
			</a>
			<p class="variable present-only">
				The single biggest cause of frustration
			</p>
			<p class="variable">
				Incorrect or overly-complex designs for starting, stopping,
				and inspecting goroutines is the single biggest cause of 
				frustration faced by new and intermediate Go programmers,
				in my experience.
			</p>
		</div>

		<div class="variable slide">
			<p class="variable">
				I think the problem is that goroutines are, ultimately, a very low-level
				building block, with few affordances for the sort of higher-order tasks that
				most people want to accomplish with concurrency.
				
				We say things like "never start a goroutine without knowing how it will stop,"
				but this advice is somewhat empty without a concrete methodology.
				
				And I think many tutorials and lots of example code, even in
				otherwise good references like The Go Programming Language book,
				do us a disservice by demonstrating concurrency concepts with
				fire-and-forget goroutines, global state, and patterns that
				would fail even basic code review.
			</p>
			<p class="variable">
				Most goroutines I see launched by my colleagues are not 
				incidental steps of a well-defined concurrent algorithm.
				They tend to be structural, managing long-running things with indistinct
				termination semantics, often started at the beginning of a program.
				I think these use cases need to be served with stronger conventions.
			</p>
			<p class="variable present-only">
				<br/>
				I think this is because goroutines are often too low-level.
			</p>
			<h3 class="variable present-only">
				What if the <em>go</em> keyword had different orthotics?
			</h3>
			<p class="variable">
				Imagine for a moment that the orthotics of the go keyword were slightly different.
				What if we couldn't launch a goroutine without also necessarily providing a function
				to interrupt or stop it? In effect, enforcing the convention that goroutines 
				shouldn't be started unless we know how they'll be stopped.
			</p>
		</div>

		<div class="variable slide">
			<p class="variable">
				This is what I've stumbled over with 
				<a href="https://godoc.org/github.com/oklog/run">package run</a>, 
				extracted from a larger project I was working on last year.
				Here's the most important method, Add:
			</p>
			<pre class="variable">
func (g *Group) Add(execute func() error, interrupt func(error))
</pre>
			<p class="variable">
				Add queues a goroutine to be run, but also tracks a function that will
				interrupt the goroutine when it needs to be killed. That enables
				well-defined termination semantics for the group of goroutines as a whole.
				For example, I use it most often when I have multiple server components
				that should run forever, and then Add a goroutine to trap ctrl-C and tear 
				everything down.
			</p>
		</div>
		<div class="slide variable">
			<pre class="variable">
ctx, cancel := context.WithCancel(context.Background())
g.Add(func() error {
	c := make(chan os.Signal, 1)
	signal.Notify(c, syscall.SIGINT, syscall.SIGTERM)
	select {
	case sig := <-c:
		return fmt.Errorf("received signal %s", sig)
	case <-ctx.Done():
		return ctx.Err()
	}
}, func(error) {
	cancel()
})
</pre>			
			<p class="variable">
				If you're familiar with
				<a href="https://godoc.org/golang.org/x/sync/errgroup">package errgroup</a>,
				this is similar at a high level, but the devil's in the details:
				errgroup implicitly assumes all execute funcs will respond to
				the parent context provided to the group, and has no affordance
				to make that explicit.
			</p>
		</div>

		<div class="variable slide">
			<p class="variable">
				There was 
				<a href="https://vorpus.org/blog/notes-on-structured-concurrency-or-go-statement-considered-harmful/">a recent clickbaity blog post</a>
				that claimed the "go statement considered harmful," and
				advocated for a construct it called a <em>nursery</em>, of
				lifecycle-bound threads. Both package run and package errgroup
				are slightly different implementation-interpretations of this
				nursery concept.
			</p>
			<img src="go-statement-considered-harmful.png" class="variable present-only" style="max-height: 80%; margin: 1em; border: solid 1px #000;"/>
		</div>

		<div class="variable slide">
			<a name="futures">
				<h3 class="variable">
					<a href="#futures">Futures</a>
				</h3>
			</a>
			<p class="variable">
				So this is one form of higher-order structure.
				But there are plenty of others!
				For example, did you know Go had futures?
				It's just a little bit more verbose than it might be in other languages.
			</p>
			<pre class="variable">
future := make(chan int, 1)
go func() { future <- process() }()
result := <-future
</pre>
			<p class="">
				Another way of pronouncing "future" is "async/await".
			</p>
			<pre class="variable">
c := make(chan int, 1)
go func() { c <- process() }() // async
v := <-c                       // await
</pre>
		</div>
		<div class="variable slide">
			<a name="scatter-gather">
				<h3 class="variable">
					<a href="#scatter-gather">Scatter-gather</a>
				</h3>
			</a>
			<p class="variable">
				We also have scatter-gather, which I use all the time,
				when I know precisely how many units of work I need to process.
			</p>
			<pre class="variable">
// Scatter
c := make(chan result, 10)
for i := 0; i < cap(c); i++ {
	go func() {
		val, err := process()
		c <- result{val, err}
	}()
}

// Gather
var total int
for i := 0; i < cap(c); i++ {
	res := <-c
	if res.err != nil {
		total += res.val
	}
}
</pre>
			<p class="variable">
				A good Go programmer will have a strong command of several of
				these higher-order concurrency patterns. A great Go programmer
				will be proactive in teaching those patterns to their
				colleagues.
			</p>
		</div>

		<div class="variable slide">
			<a name="observability">
				<h2 class="variable rotate_n1deg">
					<a class="pad shade_green" href="#observability">Observability</a>
				</h2>
			</a>
			<p class="variable">
				I largely agree with what Charity told us earlier in the
				program. In particular, I agree that a core invariant of our
				distributed industrial systems is that there's simply no cost-effective way
				to do comprehensive integration or smoke testing. Integration or
				test environments are largely a waste; 
				<a href="https://bravenewgeek.com/more-environments-will-not-make-things-easier/">more environments will not make things easier</a>.
				For most of our systems, good observability is simply more
				important than good testing, because good observability enables
				smart organizations to focus on fast deployment and rollback,
				optimizing for mean time to recovery (MTTR) instead of mean time
				between failure (MTBF).
			</p>
			<p class="variable">
				The question for us is: what does a properly observable system
				in Go look like? I guess there's no single answer, no package I
				can tell you to import to solve the problem once and for all.
				The observability space is fractured, with many vendors
				competing for their particular worldview. There's a lot to be
				excited about, but the dust hasn't settled on winners yet. While
				we wait for that to happen, what can we do in the meantime?
			</p>
		</div>

		<div class="variable slide">
			<h3 class="variable present-only">
				The three pillars of observability
			</h3>
			<img src="venn.png" class="variable class02 push-left" />
			<p class="variable">
				If we lived in a more perfect world, it wouldn't matter. If we
				had a perfect observability data collection system, where all
				interpretation could be done at query-time with zero cost, we
				could emit raw observations to it, with infinite detail, and
				be done with it. But what makes the field interesting, or
				challenging, is of course that no such data system exists. So
				we’ve had to make engineering decisions, compromises, imbuing
				certain types of observations with semantic meaning, to enable
				specific observability workflows.
			</p>
			<p class="variable">
				Metrics, logging, and tracing are emergent <em>patterns of
				consumption</em> of observability data, which inform the way we
				produce, ship, and store the corresponding signals. They’re the
				product of an optimization function, between how operators want
				to be able to introspect over their systems, and the capability
				of technology to meet those demands at scale. There may be
				other, yet-undiscovered patterns of consumption, likely driven
				by advances in technology, which will usher in a new era and
				taxonomy of observability. But this is where we’re at today, and
				for the forseeable future. So let's see how to best leverage
				each of them in Go.
			</p>
			<img src="metrics.png" class="variable class02 push-right no-present" />
			<a name="metrics">
				<h3 class="variable no-present"><a href="#metrics">Metrics</a></h3>
			</a>
			<p class="variable">
				Metrics are counters, gauges, and histograms, whose observations
				are statistically combined and reported to a system that allows
				fast, real-time exporation of aggregate system behavior. Metrics
				power dashboards and alerts.
			</p>
			<p class="variable">
				Most metric systems provide Go client libraries by this point,
				and the standard exposition formats, like StatsD, are pretty
				well understood and implemented. If your organization already
				has institutional knowledge around a given system, standardize
				on it; if you're just getting started or looking to converge on
				one system, Prometheus is best-in-class.
			</p>
			<p class="variable">
				What isn't good enough anymore are host- or check-based systems
				like Nagios, Icinga, or Ganglia. These keep you trapped in 
				monitoring paradigms that stopped making sense a long time ago,
				and actively impede making your system observable.
			</p>
			<img src="logging.png" class="variable class02 push-right no-present" />
			<a name="logging">
				<h3 class="variable no-present"><a href="#logging">Logging</a></h3>
			</a>
			<p class="variable">
				Logs are streams of discrete events reported at full fidelity to
				a collection system, for later analysis, reporting, and
				debugging. Good logs are structured and permit flexible post-hoc
				manipulation.
			</p>
			<p class="variable">
				There are lots of great logging options in Go these days. Good
				logging libraries are oriented around a logger interface, rather
				than a concrete logger object. They treat loggers as
				dependencies, avoiding package global state. And they enforce
				structured logging at callsites.
			</p>
			<p class="variable">
				Logs are abstract streams, not concrete files, so avoid loggers
				that write or rotate files on disk; that's the responsibility of
				another process, or your orchestration platform. And logging can
				quickly dominate runtime costs of a system, so be careful and
				judicious in how you produce and emit logs. Capture everything
				relevant in the request path, but do so thoughtfully, using
				patterns like decorators or middlewares.
			</p>
			<img src="tracing.png" class="variable class02 push-right no-present" />
			<a name="tracing no-present">
				<h3 class="variable no-present"><a href="#tracing">Tracing</a></h3>
			</a>
			<p class="variable">
				Tracing deals with all request-scoped performance data,
				especially as that data crosses process and system boundaries in
				a distributed system. Tracing systems organize metadata into
				tree structures, enabling deep-dive triage sessions into
				specific anomalies or events.
			</p>
			<p class="variable">
				Tracing implementations these days are centered around
				OpenTracing, a client-side API standard implemented by
				concrete systems like Zipkin, Jaeger, Datadog, and others.
				There's also interesting work being done in OpenCensus,
				which promises a more integrated environment.
			</p>
			<p class="variable">
				Tracing needs to be comprehensive if it's going to be useful,
				and of all of the pillars of observability it has the strictest
				set of domain objects and verbs. For those reasons the costs of
				properly implementing tracing are very high, and may only make
				sense to start working on when your distributed system is quite
				large, perhaps beyond several dozen microservices.
			</p>
		</div>
		<div class="variable slide">
			<p class="variable">
				&mdash;
			</p>
			<p class="variable">
				Each pillar of observability has different strengths and weaknesses.
				I think we can compare them along different axes:
				<strong>CapEx</strong>, the initial cost to start instrumenting and collecting the signals;
				<strong>OpEx</strong>, the ongoing cost to run the supporting infrastructure;
				<strong>Reaction</strong>, how good the system is at detecting and alerting on incidents; and
				<strong>Investigation</strong>, how much the system can help to triage and debug incidents.
				My subjective opinions follow:
			</p>
			<table  class="variable" cellpadding="10">
				<tr>
					<th></th>
					<th class="top">Metrics</th>
					<th class="top">Logging</th>
					<th class="top">Tracing</th>
				</tr>
				<tr>
					<th class="left">CapEx</th>
					<td class="medium">Medium</td>
					<td class="low">Low</td>
					<td class="high">High</td>
				</tr>
				<tr>
					<th class="left">OpEx</th>
					<td class="low">Low</td>
					<td class="high">High</td>
					<td class="medium">Medium</td>
				</tr>
				<tr>
					<th class="left">Reaction</th>
					<td class="high">High</td>
					<td class="medium">Medium</td>
					<td class="low">Low</td>
				</tr>
				<tr>
					<th class="left">Investigation</th>
					<td class="low">Low</td>
					<td class="medium">Medium</td>
					<td class="high">High</td>
				</tr>
			</table>
			<p class="variable">
				In terms of CapEx, logging systems are the easiest to get
				started, and adding log instrumentation to your code is easier
				and more intuitive than the alternatives. Metrics are a bit more
				involved to add, but most metrics collection systems are still
				relatively self-contained and pretty easy to deploy. Tracing, in
				contrast, is time-intensive to install across your fleet, and
				the tracing collection systems are typically large and require
				some specialized database knowledge.
			</p>
			<p class="variable">
				In terms of OpEx, it's my experience that keeping a logging
				system online takes disproportionate effort, often being just as
				hard or harder than the corresponding production
				systems&mdash;made more difficult by the tendency for most
				organizations to indiscriminately over-log. Tracing systems
				benefit from the upfront costs and generally get on OK with
				aggressive ingest sampling and regular database maintenance.
				Metrics systems, in constrast, benefit from the natural data
				compression that occurs from statistical aggregation, and have
				generally very low maintenance costs.
			</p>
			<p class="variable">
				In terms of reactive capability, metrics systems are explicitly
				designed to serve dashboard and alert use cases, and excel here.
				Logging systems frequently have tooling to perform aggregates or
				roll-ups that can drive dashboards and alerts, with a bit of
				work. And tracing systems generally don't have an ability to
				detect or signal on anomalies.
			</p>
			<p class="variable">
				When it comes to investigation, however, the tables are turned.
				Metric systems lose data fidelity by design, and usually provide
				no good way to dig into the root cause of a problem after it's
				detected. Logging systems do much better, especially if you do
				structured logging and a logging system with a rich query language.
				And tracing is essentially designed for deep dives on specific
				requests or request-classes, sometimes being the only way to
				identify complex maladaptive behaviors.
			</p>
		</div>

		<div class="variable slide">
			<p class="variable">
				&mdash;
			</p>
			<p class="variable">
				The lesson here is that no single observability paradigm
				will solve all of your observability needs;
				they're all part of a complete observability breakfast.
				From their unique characteristics I think we can derive some general
				advice: 
			</p>
			<ol class="variable">
				<li>First, invest in basic, comprehensive metrics, to power
				a uniform set of dashboards and alerts for your components.</li>
				<li>Next, invest in deep, high-cardinality, structured logging for
				incident triage and debugging.</li>
				<li>Finally, once you're at a
				large-enough scale and have well-defined production readiness
				standards, investigate distributed tracing.</li>
			</ol>
			<ol class="variable present-only">
				<li>First, <strong>metrics</strong></li>
				<li>Next, <strong>structured logging</strong></li>
				<li>Finally, <strong>distributed tracing</strong></li>
			</ol>
		</div>

		<div class="variable slide">
			<a name="testing">
				<h2 class="variable rotate_1deg">
					<a class="pad shade_red" href="#testing">Testing</a>
				</h2>
			</a>
			<h3 class="variable present-only">
				A sanity check
			</h3>
		</div>

		<div class="variable slide">
			<a href="https://twitter.com/peterbourgon/status/989571449856798720">
				<img src="test.png" class="variable class02 push-right"/>
			</a>
			<p class="variable">
				Although observability probably trumps integration testing for
				large distributed systems, unit and limited integration testing
				is still fundamental and necessary for any software project. In
				industrial contexts especially, I think its greatest value is
				providing a sort of sanity-check layer to new maintainers that
				their changes have the intended scope and effect.
			</p>
		</div>

		<div class="variable slide">
			<p class="variable">
				It follows that tests should optimize for ease-of-use. If an
				entry-level developer can't figure out how to run your project's
				tests immediately after cloning the repo, there is a serious
				problem. In Go, I think this means that running plain go test in
				your project with no additional set-up work should always
				succeed without incident. That is, most tests should not require
				any sort of test environment, running database, etc. to function
				properly and return success. Those tests that do are integration
				tests, and they should be opt-in via test flag or environment
				variable:
			</p>
			<pre class="variable">
func TestComplex(t *testing.T) {
	urn := os.Getenv("TEST_DB_URN")
	if urn == "" {
		t.Skip("set TEST_DB_URN to run this test")
	}
	
	db, _ := connect(urn)
	// ...
}</pre>
			<a href="https://testing.googleblog.com/2015/04/just-say-no-to-more-end-to-end-tests.html">
				<img src="testing-pyramid.png" class="variable push-right no-present"/>
			</a>
			<p class="variable">
				<a href="https://testing.googleblog.com/2015/04/just-say-no-to-more-end-to-end-tests.html">The testing pyramid</a>
				is good general advice, and 
				suggests that you should focus most of your efforts on
				unit testing. In my experience, the ideal ratios are even more extreme than
				the pyramid suggests: if you have good production observability, as much as 
				80&ndash;90% of your testing effort should be focused toward unit tests.
				In Go, we know that 
				<a href="https://github.com/golang/go/wiki/TableDrivenTests">good unit tests are table-driven</a>, 
				and leverage the fact that your components
				<a href="https://blog.chewxy.com/2018/03/18/golang-interfaces/"/>accept interfaces and return structs</a>
				to provide fake or mock implementations of dependencies, 
				and
				<a href="https://peter.bourgon.org/go-best-practices-2016/#top-tip-12">test only the thing being tested</a>.
			</p>
		</div>

		<div class="variable slide">
			<a href="https://www.youtube.com/watch?v=8hQG7QlcLBk">
				<img src="advanced-testing.png" class="variable class02 push-left"/>
			</a>
			<p class="variable">
				I like to reference this talk as frequently as possible:
				Mitchell Hashimoto's 
				<a href="https://www.youtube.com/watch?v=8hQG7QlcLBk">Advanced Testing with Go</a>
				from last year's GopherCon is probably the single best source of
				information about good Go program design in industrial contexts
				I've seen to date. If your team writes Go, it's essential
				background material.
			</p>
			<p class="variable">
				There's not much more to say on the subject. The relative
				stability of testing best practices over time is a welcome
				reprieve. As before and as always: gunning for 100% test
				coverage is almost certainly counterproductive, but 50% seems
				like a good low watermark; and avoid introducing testing DSLs or
				"helper packages" unless and until your team gets explicit,
				concrete value from them.
			</p>
		</div>

		<div class="variable slide">
			<a name="how-much-interface-do-i-need">
				<h2 class="variable rotate_n1deg">
					<a class="pad shade_blue" href="#how-much-interface-do-i-need">How much interface do I need?</a>
				</h2>
			</a>
			<p class="variable">
				When we talk about testing, we talk about mocking dependencies
				via interfaces, but we often don't really describe how that
				works in practice. I think it's important to observe that the Go
				type system is not nominal, but rather
				<a href="https://blog.chewxy.com/2018/03/18/golang-interfaces/">it is structural</a>.
				Looking at interfaces as a way to classify implementations is the
				wrong approach; instead, look at interfaces as a way to identify
				code that expects common sets of behaviors. Said another way,
				interfaces are consumer contracts, not producer (implementor)
				contracts&mdash;so, as a rule, we should be defining them at
				callsites in consuming code, rather than in the packages that
				provide implementations.
			</p>
			<h3 class="variable present-only">
				The Go type system is structural, not nominal
			</h3>
			<p class="variable present-only">
				Interfaces belong with consumers, not implementers
			</p>
		</div>

		<div class="variable slide">
			<p class="variable">
				How much interface do you need? Well, there's a spectrum. As
				much as makes sense at your callsites, especially with the aim
				to help testing. At one extreme, we could model every dependency
				to every function with a tightly-scoped interface definition. In
				limited circumstances this may make sense! For example, if your
				components are coarse-grained, well-established, and unlikely to
				change in the future.
			</p>
			<h3 class="variable present-only">
				Define interfaces at fault lines
			</h3>
			<ul class="variable present-only">
				<li>Between func main and the rest of the program</li>
				<li>At package APIs</li>
			</ul>
			<p class="variable">
				But especially in industrial contexts, it's more likely that
				you'll have a mix of abstractions, which are fluctuating over
				time. In this case, you'll probably want to try to define
				interfaces at "fault lines" in your design. Two natural boundary
				points are between func main and the rest of your code, and
				along package APIs. Defining dependency interfaces there is a
				great place to start, as well as a great place to start thinking
				about defining unit tests.
			</p>
		</div>

		<div class="variable slide">
			<a name="context-use-and-misuse">
				<h2 class="variable rotate_1deg">
					<a class="pad shade_orange" href="#context-use-and-misuse">Context use and misuse</a>
				</h2>
			</a>
			<p class="variable">
				Go 1.7 brought us package context, and since then, it's been
				steadily infecting our code. This isn't a bad thing!
				Contexts are a well-understood and ubiquitous way to 
				<a href="#goroutine-lifecycle-management">manage goroutine lifecycles</a>, 
				which is a big and hard problem. In my experience this is their
				most important function. If you have a component that blocks for
				any reasons&mdash;typically network I/O, sometimes disk I/O,
				maybe due to user callbacks, and so on&mdash;then it should
				probably take a context as its first parameter.
			</p>
		</div>
			
		<div class="variable slide">
			<p class="variable">
				The pattern is so ubiquitous, I've started to design this into
				my server types and interfaces from the beginning. Here's an
				example from a recent project that connected to Google Cloud
				Storage:
			</p>
			<h3 class="variable present-only">
				Contexts for lifecycle management
			</h3>
			<p class="variable present-only">
				A good idea
			</p>
			<pre class="variable">
// reportStore is a thin domain abstraction over GCS.
type reportStore interface {
	listTimes(ctx context.Context, from time.Time, n int) ([]time.Time, error)
	writeFile(ctx context.Context, ts time.Time, name string, r io.Reader) error
	serveFile(ctx context.Context, ts time.Time, name string, w io.Writer) error
}
</pre>
		</div>

		<div class="variable slide">
			<p class="variable">
				Writing components to be context-aware for lifecycle semantics
				is straightforward: just make sure your code responds to
				<a href="https://golang.org/pkg/context/#Context">ctx.Done</a>. 
				Using the value propegation features of contexts has
				proven to be a bit trickier. 
				
				The problem with context.Value is that the key and value are
				untyped and not guaranteed to exist, which opens your program up
				to runtime costs and failure modes that may otherwise be
				avoidable.
				
				My experience has been that developers over-use context values
				for things that really ought to be regular dependencies or
				function parameters.
			</p>
			<h3 class="variable present-only">
				Contexts for value propegation
			</h3>
			<p class="variable present-only">
				Only for request-scoped data
			</p>
			<p class="variable">
				So, one essential of thumb: only use context.Value for data that
				can't be passed through your program in any other way. In
				practice, this means only using context.Value for
				<em>request-scoped information</em>, like request IDs, user
				authentication tokens, and so on. If the information is
				available when the program starts, like a database handle or
				logger, then it shouldn't be passed through the context.
			</p>
			<p class="variable">
				Again, the rationale for this advice boils down to
				maintainability. It's much better if a component enumerates its
				requirements in the form of a constructor or function parameter,
				checkable at compile time, than if it extracts information from
				an untyped, opaque bag of values, checkable only at runtime. Not
				only is the latter more fragile, it makes understanding and
				adapting code more difficult.
			</p>
		</div>

		<div class="variable slide">
			<a name="in-summary">
				<h2 class="variable rotate_n1deg">
					<a class="pad shade_purple" href="#in-summary">In summary</a>
				</h2>
			</a>
			<p class="variable">
				I've been doing this best practice series for six years now,
				and while a few tips have come and gone, 
				especially in response to emerging idioms and patterns,
				what's remarkable is really how <em>little</em> the foundational knowledge
				required to be an effective Go programmer has changed in that time.
				By and large, we aren't chasing design trends.
				We have a language and ecosystem that's been remarkably stable,
				and I'm sure I don't just speak for myself when I say I really appreciate that.
			</p>
			<h3 class="variable present-only">
				Go has changed remarkably little
			</h3>
			<p class="variable present-only">
				I really appreciate that!
			</p>
		</div>
		<div class="variable slide">
			<p class="variable">
				I think it's great to orient ourselves among each other at
				conferences like this one. But I think the best thing we can do
				here is build empathy for each other. If we do our job right, as
				the number of Go programmers continues to grow, the community
				will become increasingly diverse, with different workflows,
				contexts, and goals. I'm happy to have presented some experience
				reports from my own journey with Go, and I'm excited to hear and
				understand all of yours. Thanks a bunch!
			</p>
			<h3 class="variable present-only">
				These were some of my experiences with Go
			</h3>
			<p class="variable present-only">
				I'm excited to hear all of your experiences, too!
			</p>
			<p class="variable present-only">
				<em>Thanks for listening!</em>
			</p>
		</div>
		<div class="variable slide">
			<h3 class="variable present-only">Did I time this correctly??</h3>
			<p class="variable present-only">Do I have time for questions??</p>
			<p class="variable present-only"><em>@peterbourgon</em></p>
			<p class="variable no-present">
				&mdash; &ndash;<br/>
				<em><a href="https://twitter.com/peterbourgon">Read my tweets</a> or
					<a href="/">go back to my website</a>.</em>
			</p>
		</div>
	</div>

	<script>
		$("#present-button").click(function () {
			if ($(this).html() == "Present") {
				$(this).html("Done");
			} else {
				$(this).html("Present")
			}
			$(".variable").each(function () {
				$(this).toggleClass("present");
			});
		});
	</script>
</body>

</html>